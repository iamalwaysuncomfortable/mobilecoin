// Copyright (c) 2018-2022 The MobileCoin Foundation

//! Types for reading and writing historical Intel Attestation
//! Verification Reports from MobileCoin consensus enclaves

use crate::{ParseError, ValidationError};
use mc_attest_core::VerificationReportData;
use mc_attest_verifier::Verifier;
use mc_blockchain_types::{BlockData, BlockIndex, VerificationReport};
use mc_common::ResponderId;
use mc_crypto_keys::Ed25519Public;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ops::RangeInclusive, path::Path};

/// Object representing history of attestation verification reports
/// (AVR) for all consensus nodes mapped by block signing key.
///
/// The following details relevant details should be noted:
/// 1. The Block Signing key is derived from the AVR
/// 2. There is a unique a unique AVR for every enclave session. If
/// a consensus node restarts a new AVR and block signing key will
/// be generated. This results in a unique block signing key and AVR
/// for each contiguous range of blocks.
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AvrValidator {
    /// Map of block signing key to AVR Record
    pub avr_history: HashMap<Ed25519Public, AvrValidationRecord>,

    /// Verifier used to validate AVRs were generated by an properly
    /// signed enclave. This is done using offline records located
    /// in the attest/verifier/data/ directory.
    pub avr_verifier: Verifier,
}

/// Struct representing the range of blocks and responder an Intel
/// Attestation Verification Report was valid for.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AvrValidationRecord {
    /// Block range the AVR was valid for
    pub block_range: RangeInclusive<BlockIndex>,

    /// Responder ID of the consensus node containing the enclave
    /// session that generated the AVR.
    pub responder_id: ResponderId,

    /// Intel Attestation Verification Report for the enclave session
    pub avr: VerificationReport,
}

impl AvrValidator {
    /// Validate the Block Signing Key and Attestation Verification Report
    /// for a block
    pub fn validate_block_signing_key_and_avr(
        &self,
        block_data: &BlockData,
        responder_id: &Option<ResponderId>,
    ) -> Result<(), ValidationError> {
        let block_index = block_data.block().index;
        let signer = block_data
            .signature()
            .ok_or(ValidationError::NoBlockSignature(block_index))?
            .signer();

        // If the AVR is on chain, get it directly from the block metadata, otherwise
        // check the historical records for the AVR
        let avr = match block_data.metadata() {
            Some(metadata) => metadata.contents().verification_report(),
            None => {
                let record = self
                    .avr_history
                    .get(signer)
                    .ok_or_else(|| ValidationError::AvrNotFound(hex::encode(signer)))?;
                if !record.block_range.contains(&block_index) {
                    return Err(ValidationError::BlockSigningKeyExpired(block_index));
                }
                if let Some(responder_id) = responder_id {
                    if record.responder_id != *responder_id {
                        return Err(ValidationError::ResponderIdMismatch(
                            record.responder_id.clone(),
                            responder_id.clone(),
                        ));
                    }
                }
                &record.avr
            }
        };

        // Ensure the AVR was generated by an enclave signed by Intel and that
        // the reported signing key for the block matches the key in the AVR.
        self.block_signing_key_matches_avr(signer, avr)
    }

    /// Check AVR was generated by an Intel signed enclave
    pub fn verify_avr(
        &self,
        avr: &VerificationReport,
    ) -> Result<VerificationReportData, ValidationError> {
        Ok(self.avr_verifier.verify(avr)?)
    }

    /// Check that the AVR is valid and that the block signing key matches the
    /// AVR
    pub fn block_signing_key_matches_avr(
        &self,
        signing_key: &Ed25519Public,
        avr: &VerificationReport,
    ) -> Result<(), ValidationError> {
        let report_data = self.verify_avr(avr)?;
        let report_data_bytes = report_data.signing_key_bytes()?;
        let avr_signing_key = Ed25519Public::try_from(report_data_bytes.as_slice())?;
        if avr_signing_key != *signing_key {
            Err(ValidationError::InvalidBlockSigningKey(
                hex::encode(signing_key),
                hex::encode(avr_signing_key),
            ))
        } else {
            Ok(())
        }
    }

    /// Create AVR validate from AVR history config file
    pub fn load(path: impl AsRef<Path>) -> Result<Self, ParseError> {
        let mut avr_history = crate::metadata::avr::AvrConfig::load(path)?;
        Ok(avr_history.create_avr_validator()?)
    }
}
