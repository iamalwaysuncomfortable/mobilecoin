// Copyright (c) 2018-2022 The MobileCoin Foundation

//! Tools for verifying the Intel Attestation Verification Reports
//! associated with blocks produced by the MobileCoin network.

use crate::{AvrHistoryConfig, VerificationError};
use mc_attest_core::VerificationReportData;
use mc_attest_verifier::Verifier;
use mc_blockchain_types::{BlockData, BlockIndex, VerificationReport};
use mc_common::ResponderId;
use mc_crypto_keys::Ed25519Public;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ops::RangeInclusive};

/// This struct provides methods to verify that an Intel Attestation
/// Verification Report (or AVR) associated with a block was produced
/// by an Intel signed enclave and that the block signing key associated
/// with a block matches the signing key in the AVR. AVRs are represented
/// by the [VerificationReport] struct.
///
/// The following relevant details should be noted:
/// 1. The Block Signing key is derived from the AVR
/// 2. There is a unique AVR for every enclave session. If a consensus
/// node restarts, a new AVR containing a new block signing key will
/// be generated. This results in a unique block signing key and AVR
/// for each contiguous range of blocks.
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AvrVerifier {
    /// Map of historical block signing key to [AvrVerificationRecord]
    /// used to verify AVRs for blocks generated before AVRs were
    /// was included on chain.
    pub avr_history: HashMap<Ed25519Public, AvrVerificationRecord>,

    /// [Verifier] used to verify AVRs were generated by an Intel
    /// signed enclave.
    pub avr_verifier: Verifier,
}

/// Struct representing the range of blocks and [ResponderId] that
/// an AVR was valid for.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AvrVerificationRecord {
    /// Block range the AVR was valid for
    pub block_range: RangeInclusive<BlockIndex>,

    /// [ResponderID] of the consensus node containing the enclave
    /// that generated the AVR.
    pub responder_id: ResponderId,

    /// Intel Attestation Verification Report (AVR) for the enclave
    pub avr: VerificationReport,
}

impl AvrVerifier {
    /// Create new AVR verifier
    pub fn new(
        avr_history_config: &AvrHistoryConfig,
        avr_verifier: &Verifier,
    ) -> Result<Self, VerificationError> {
        avr_history_config.verify_data(avr_verifier)
    }

    /// Verify the block signing key matches the signing key within the
    /// Attestation Verification Report (AVR) associated with a block and
    /// that the AVR was produced by an Intel signed enclave.
    ///
    /// # Arguments
    ///
    /// * `block_data` - [BlockData] for the block we want to verify an AVR
    /// and block signing key for.
    /// * `responder_id` - Optional [ResponderId] to verify historical AVRs
    /// against. Each [AvrVerificationRecord] includes a BlockRange and
    /// ResponderId an AVR was valid for. If this arg is provided, the function
    /// additionally ensures that the ResponderId matches the ResponderId in
    /// the record.
    pub fn verify_block_signing_key_and_avr(
        &self,
        block_data: &BlockData,
        responder_id: &Option<ResponderId>,
    ) -> Result<(), VerificationError> {
        let block_index = block_data.block().index;
        let signer = block_data
            .signature()
            .ok_or(VerificationError::NoBlockSignature(block_index))?
            .signer();

        // If the AVR is on chain, get it directly from the block metadata, otherwise
        // check the historical records for the AVR
        let avr = match block_data.metadata() {
            Some(metadata) => metadata.contents().verification_report(),
            None => {
                // Check the historical records for an AVR corresponding to the block's
                // reported block signing key
                let record = self
                    .avr_history
                    .get(signer)
                    .ok_or_else(|| VerificationError::AvrNotFound(hex::encode(signer)))?;
                // Check the block index is within the range that the AVR was valid for
                if !record.block_range.contains(&block_index) {
                    return Err(VerificationError::BlockSigningKeyNotInRange(block_index));
                }
                // If a responder ID is provided, check that the AVR and block signing key
                // matches the history for that ResponderId.
                if let Some(responder_id) = responder_id {
                    if record.responder_id != *responder_id {
                        return Err(VerificationError::ResponderIdMismatch(
                            record.responder_id.clone(),
                            responder_id.clone(),
                        ));
                    }
                }
                &record.avr
            }
        };

        // Ensure the AVR was generated by an enclave signed by Intel and that
        // the reported signing key for the block matches the key in the AVR.
        self.block_signing_key_matches_avr(signer, avr)
    }

    /// Check the [VerificationReport] was generated by an Intel signed enclave
    ///
    /// # Arguments
    /// * `avr` - Intel Attestation Verification Report (AVR) to verify
    pub fn verify_avr(
        &self,
        avr: &VerificationReport,
    ) -> Result<VerificationReportData, VerificationError> {
        Ok(self.avr_verifier.verify(avr)?)
    }

    /// Check that block signing key reported by a block matches the signing
    /// key in the [VerificationReport]. This method also uses the verify_avr
    /// method to ensure the AVR was generated by an Intel signed enclave.
    ///
    /// (Note: this methods remains separate from verify_avr because there
    /// may be historical blocks in which the block signing key is not
    /// explicitly provided on chain and thus cannot use this method.)
    ///
    /// # Arguments
    ///
    /// `block_signing_key` - block signing key provided by the block that
    /// is being verified
    /// 'avr' - Intel Attestation Verification Report (AVR) to verify the
    /// block signing key against
    pub fn block_signing_key_matches_avr(
        &self,
        block_signing_key: &Ed25519Public,
        avr: &VerificationReport,
    ) -> Result<(), VerificationError> {
        let report_data = self.verify_avr(avr)?;
        let derived_signing_key = get_signing_key_from_verification_report_data(&report_data)?;
        if derived_signing_key != *block_signing_key {
            Err(VerificationError::InvalidBlockSigningKey(
                hex::encode(block_signing_key),
                hex::encode(derived_signing_key),
            ))
        } else {
            Ok(())
        }
    }
}

impl TryFrom<&AvrHistoryConfig> for AvrVerifier {
    type Error = VerificationError;

    fn try_from(config: &AvrHistoryConfig) -> Result<Self, Self::Error> {
        let avr_verifier = Verifier::default();
        config.verify_data(&avr_verifier)
    }
}

/// Try to get the block signing key from [VerificationReportData]
/// data obtained from an Intel Attestation Verification Report.
///
/// # Arguments
/// * `avr_data` - parsed report data from an AVR that we want
/// try and extract the block signing key from
pub fn get_signing_key_from_verification_report_data(
    avr_data: &VerificationReportData,
) -> Result<Ed25519Public, VerificationError> {
    let report_body = avr_data
        .quote
        .report_body()
        .map_err(|err| VerificationError::AvrKeyData(err.to_string()))?;
    let report_data = report_body.report_data();
    let report_bytes: &[u8] = report_data.as_ref();
    if report_bytes.len() != 64 {
        return Err(VerificationError::AvrKeyData(format!(
            "Expected report to be 64 bytes long, got {} bytes",
            report_bytes.len()
        )));
    }
    Ok(Ed25519Public::try_from(&report_bytes[32..64])?)
}
