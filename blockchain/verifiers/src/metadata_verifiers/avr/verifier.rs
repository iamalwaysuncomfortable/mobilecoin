// Copyright (c) 2018-2022 The MobileCoin Foundation

//! Verifier that checks that an Intel Attestation Verification
//! Report (AVR) presented by a block comes from an Intel
//! signed consensus enclave and that the block signing key
//! presented matches the signing key in the AVR.

use crate::{AvrHistoryConfig, VerificationError};
use mc_attest_core::VerificationReportData;
use mc_attest_verifier::Verifier;
use mc_blockchain_types::{BlockData, BlockIndex, VerificationReport};
use mc_common::ResponderId;
use mc_crypto_keys::Ed25519Public;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, ops::RangeInclusive};

/// Object representing history of Intel Attestation Verification
/// Reports (AVR) for all consensus nodes mapped by block signing
/// key.
///
/// The following relevant details should be noted:
/// 1. The Block Signing key is derived from the AVR
/// 2. There is a unique AVR for every enclave session. If
/// a consensus node restarts a new AVR and block signing key will
/// be generated. This results in a unique block signing key and AVR
/// for each contiguous range of blocks.
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct AvrVerifier {
    /// Map of block signing key to AVR Record
    pub avr_history: HashMap<Ed25519Public, AvrVerificationRecord>,

    /// Verifier used to verify AVRs were generated by an Intel
    /// signed enclave.
    pub avr_verifier: Verifier,
}

/// Struct representing the range of blocks and responder an Intel
/// Attestation Verification Report was valid for.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AvrVerificationRecord {
    /// Block range the AVR was valid for
    pub block_range: RangeInclusive<BlockIndex>,

    /// [ResponderID] of the consensus node containing the enclave
    /// session that generated the AVR.
    pub responder_id: ResponderId,

    /// Intel Attestation Verification Report for the enclave session
    pub avr: VerificationReport,
}

impl AvrVerifier {
    /// Create new AVR verifier
    pub fn new(
        avr_history_config: &Option<AvrHistoryConfig>,
        avr_verifier: &Verifier,
    ) -> Result<Self, VerificationError> {
        if let Some(avr_history_config) = avr_history_config {
            avr_history_config.verify_data(avr_verifier)
        } else {
            Ok(Self {
                avr_history: HashMap::new(),
                avr_verifier: avr_verifier.clone(),
            })
        }
    }

    /// Verify the block signing key matches the signing key within the
    /// Attestation Verification Report (AVR) for a block and that the AVR
    /// was produced by an Intel signed enclave. If a [ResponderId] is
    /// provided, it will attempt to verify the block signing key matches
    /// the key within the [VerificationReport] for the given ResponderId
    /// for historical blocks that do not include metadata on chain.
    pub fn verify_block_signing_key_and_avr(
        &self,
        block_data: &BlockData,
        responder_id: &Option<ResponderId>,
    ) -> Result<(), VerificationError> {
        let block_index = block_data.block().index;
        let signer = block_data
            .signature()
            .ok_or(VerificationError::NoBlockSignature(block_index))?
            .signer();

        // If the AVR is on chain, get it directly from the block metadata, otherwise
        // check the historical records for the AVR
        let avr = match block_data.metadata() {
            Some(metadata) => metadata.contents().verification_report(),
            None => {
                let record = self
                    .avr_history
                    .get(signer)
                    .ok_or_else(|| VerificationError::AvrNotFound(hex::encode(signer)))?;
                if !record.block_range.contains(&block_index) {
                    return Err(VerificationError::BlockSigningKeyNotInRange(block_index));
                }
                if let Some(responder_id) = responder_id {
                    if record.responder_id != *responder_id {
                        return Err(VerificationError::ResponderIdMismatch(
                            record.responder_id.clone(),
                            responder_id.clone(),
                        ));
                    }
                }
                &record.avr
            }
        };

        // Ensure the AVR was generated by an enclave signed by Intel and that
        // the reported signing key for the block matches the key in the AVR.
        self.block_signing_key_matches_avr(signer, avr)
    }

    /// Check the [VerificationReport] was generated by an Intel signed enclave
    pub fn verify_avr(
        &self,
        avr: &VerificationReport,
    ) -> Result<VerificationReportData, VerificationError> {
        Ok(self.avr_verifier.verify(avr)?)
    }

    /// Check that the [VerificationReport] was generated by an Intel signed
    /// enclave and that the block signing key reported by a block matches
    /// they signing key in the [VerificationReport].
    pub fn block_signing_key_matches_avr(
        &self,
        block_signing_key: &Ed25519Public,
        avr: &VerificationReport,
    ) -> Result<(), VerificationError> {
        let report_data = self.verify_avr(avr)?;
        let derived_signing_key = get_signing_key_from_verification_report_data(&report_data)?;
        if derived_signing_key != *block_signing_key {
            Err(VerificationError::InvalidBlockSigningKey(
                hex::encode(block_signing_key),
                hex::encode(derived_signing_key),
            ))
        } else {
            Ok(())
        }
    }
}

impl TryFrom<&AvrHistoryConfig> for AvrVerifier {
    type Error = VerificationError;

    fn try_from(config: &AvrHistoryConfig) -> Result<Self, Self::Error> {
        let avr_verifier = Verifier::default();
        config.verify_data(&avr_verifier)
    }
}

/// Try to get the block signing key from [VerificationReportData]
/// data obtained from an Intel Attestation Verification Report.
pub fn get_signing_key_from_verification_report_data(
    avr_data: &VerificationReportData,
) -> Result<Ed25519Public, VerificationError> {
    let report_body = avr_data
        .quote
        .report_body()
        .map_err(|err| VerificationError::AvrKeyData(err.to_string()))?;
    let report_data = report_body.report_data();
    let report_bytes: &[u8] = report_data.as_ref();
    if report_bytes.len() != 64 {
        return Err(VerificationError::AvrKeyData(format!(
            "Expected report to be 64 bytes long, got {} bytes",
            report_bytes.len()
        )));
    }
    Ok(Ed25519Public::try_from(&report_bytes[32..64])?)
}
